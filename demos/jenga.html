<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Jenga 物理破坏模拟</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; }
        canvas { display: block; }
        #instruction {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="instruction">点击鼠标左键发射小球 | 按住鼠标左键拖动旋转视角</div>

    <!-- 使用 Import Map 来管理模块依赖 -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // --- 1. 初始化设置 ---
        
        // 场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // 天空蓝
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        // 摄像机
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);

        // 渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // 开启阴影
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 控制器
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 5, 0);

        // 灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- 2. 物理世界设置 (Cannon-es) ---
        
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0); // 重力
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.allowSleep = true; // 允许静止物体休眠以提高性能

        // 材质 (让积木有点摩擦力，不要太滑)
        const defaultMaterial = new CANNON.Material('default');
        const defaultContactMaterial = new CANNON.ContactMaterial(
            defaultMaterial,
            defaultMaterial,
            {
                friction: 0.4,    // 摩擦力
                restitution: 0.3  // 弹性 (反弹程度)
            }
        );
        world.addContactMaterial(defaultContactMaterial);

        // 用于同步 物理Body 和 视觉Mesh 的数组
        const objectsToUpdate = [];

        // --- 3. 辅助函数 ---

        // 创建盒体 (Jenga 积木或地面)
        const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        
        const createBox = (width, height, depth, position, color, mass = 1) => {
            // 1. Three.js Mesh
            const mesh = new THREE.Mesh(boxGeometry, new THREE.MeshStandardMaterial({ color: color }));
            mesh.scale.set(width, height, depth);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // 2. Cannon.js Body
            const shape = new CANNON.Box(new CANNON.Vec3(width * 0.5, height * 0.5, depth * 0.5));
            const body = new CANNON.Body({
                mass: mass, // mass = 0 表示静态物体(地面)
                position: new CANNON.Vec3(position.x, position.y, position.z),
                shape: shape,
                material: defaultMaterial
            });
            world.addBody(body);

            // 3. 加入更新列表
            objectsToUpdate.push({ mesh, body });
        };

        // 创建球体 (子弹)
        const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
        
        const createBall = (radius, position, direction) => {
            // Mesh
            const mesh = new THREE.Mesh(sphereGeometry, new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.4 }));
            mesh.scale.set(radius, radius, radius);
            mesh.castShadow = true;
            scene.add(mesh);

            // Body
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({
                mass: 5, // 球重一点，威力大
                position: new CANNON.Vec3(position.x, position.y, position.z),
                shape: shape,
                material: defaultMaterial
            });
            
            // 施加初始速度
            const shootVelocity = 35;
            body.velocity.set(
                direction.x * shootVelocity,
                direction.y * shootVelocity,
                direction.z * shootVelocity
            );

            world.addBody(body);
            objectsToUpdate.push({ mesh, body });
        };

        // --- 4. 搭建场景 ---

        // 地面
        createBox(50, 0.5, 50, { x: 0, y: -0.25, z: 0 }, 0x444444, 0);

        // 搭建 Jenga 塔
        // 标准比例大约是：长:宽:高 = 3:1:0.6 左右，这里简化处理
        const blockWidth = 2.0;
        const blockHeight = 1.0; 
        const blockDepth = 6.0; // 长度是宽度的3倍
        const levels = 12;      // 层数

        for (let i = 0; i < levels; i++) {
            const y = 0.5 + i * blockHeight; // 垂直位置
            const isEven = i % 2 === 0;      // 奇偶层交替方向

            for (let j = 0; j < 3; j++) {
                // 计算偏移，让它们并排
                // 3个积木并排，中间那个是0，两边是 +/- 宽度
                const offset = (j - 1) * (blockWidth + 0.05); // 0.05 是微小缝隙，防止物理引擎计算重叠卡死

                let x, z, w, d;
                
                if (isEven) {
                    // 偶数层：沿 X 轴摆放 (长边在 Z 轴，短边在 X 轴... 不对，是横着放)
                    // 修正：我们要让积木长边沿 Z 轴或者 X 轴
                    // 层1：||| (长边沿 Z) -> w=width, d=depth
                    // 层2：=== (长边沿 X) -> w=depth, d=width
                    
                    w = blockWidth;
                    d = blockDepth;
                    x = offset;
                    z = 0;
                } else {
                    w = blockDepth;
                    d = blockWidth;
                    x = 0;
                    z = offset;
                }

                // 随机颜色让它好看点
                const hue = 30 + Math.random() * 20; // 橙黄色调
                const color = new THREE.Color(`hsl(${hue}, 80%, 70%)`);

                createBox(w, blockHeight, d, { x, y, z }, color, 1);
            }
        }

        // --- 5. 交互 (发射子弹) ---

        window.addEventListener('click', () => {
            // 获取发射位置（摄像机位置）
            const startPos = camera.position.clone();
            
            // 获取发射方向（摄像机正前方）
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            // 稍微把球的生成位置往前移一点，免得卡在摄像机里
            startPos.add(direction.clone().multiplyScalar(2));

            createBall(0.6, startPos, direction);
        });

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 6. 动画循环 ---

        const clock = new THREE.Clock();
        let oldElapsedTime = 0;

        const tick = () => {
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = elapsedTime - oldElapsedTime;
            oldElapsedTime = elapsedTime;

            // 更新物理世界
            // 固定步长 1/60 秒
            world.step(1 / 60, deltaTime, 3);

            // 同步物理数据到渲染网格
            for (const object of objectsToUpdate) {
                object.mesh.position.copy(object.body.position);
                object.mesh.quaternion.copy(object.body.quaternion);
            }

            // 更新控制器
            controls.update();

            // 渲染
            renderer.render(scene, camera);

            // 下一帧
            window.requestAnimationFrame(tick);
        };

        tick();
    </script>
</body>
</html>